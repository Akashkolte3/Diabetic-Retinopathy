# -*- coding: utf-8 -*-
"""Copy of efficientnet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jchYjommB1U7ZBsyFqAsGrnj4LoYbrIi
"""

from google.colab import drive
drive.mount('/content/gdrive')

!pip install efficientnet

cd /content/gdrive/MyDrive/college

!apt-get -qq install -y libfluidsynth1

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, GlobalAveragePooling2D
from tensorflow.keras.optimizers import Adam
from efficientnet.tfkeras import EfficientNetB0

# Set the input image size and number of classes
IMG_SIZE = 224
NUM_CLASSES = 5

# Define the data generators for loading images
train_data_generator = ImageDataGenerator(rescale=1./255,
                                           shear_range=0.2,
                                           zoom_range=0.2,
                                           horizontal_flip=True)

validation_data_generator = ImageDataGenerator(rescale=1./255)

train_generator = train_data_generator.flow_from_directory('/content/gdrive/MyDrive/college/train.jpeg',
                                                            target_size=(IMG_SIZE, IMG_SIZE),
                                                            batch_size=32,
                                                            class_mode='categorical')

validation_generator = validation_data_generator.flow_from_directory('/content/gdrive/MyDrive/college/test.jpeg',
                                                                      target_size=(IMG_SIZE, IMG_SIZE),
                                                                      batch_size=32,
                                                                      class_mode='categorical')

# Define the model architecture
model = Sequential()

base_model = EfficientNetB0(include_top=False, input_shape=(IMG_SIZE, IMG_SIZE, 3))

model.add(base_model)
model.add(GlobalAveragePooling2D())
model.add(Dense(256, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(NUM_CLASSES, activation='softmax'))

# Compile the model
model.compile(optimizer=Adam(lr=0.001), loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
model.fit(train_generator, epochs=20, validation_data=validation_generator)

!pip install efficientnet_pytorch

!mkdir -p /content/drive/MyDrive/

model.save('efficientnet_model.h5')

import tensorflow as tf
import numpy as np
from tensorflow.keras.preprocessing import image

# Load the EfficientNet model
model = tf.keras.models.load_model('efficientnet_model.h5')

# Load an image to be classified
img_path = '//content/gdrive/MyDrive/12345/test/No_DR Clahe/Clahe_imgs/processed_fusion_1040-1041_L.png'
img = image.load_img(img_path, target_size=(224, 224))

# Preprocess the image
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)
img_array = tf.keras.applications.efficientnet.preprocess_input(img_array)

# Make predictions
predictions = model.predict(img_array)

# Get predicted class index
class_idx = np.argmax(predictions[0])
if class_idx >= len(class_names):
    class_idx = len(class_names) - 1

class_names = ['No Diabetes Retinopathy', 'Severe']
class_name = class_names[class_idx]

print('Predicted class:', class_name)

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, GlobalAveragePooling2D
from tensorflow.keras.optimizers import Adam
from efficientnet.tfkeras import EfficientNetB0

# Set the input image size and number of classes
IMG_SIZE = 224
NUM_CLASSES = 5

# Define the data generators for loading images
train_data_generator = ImageDataGenerator(rescale=1./255,
                                           shear_range=0.2,
                                           zoom_range=0.2,
                                           horizontal_flip=True)

validation_data_generator = ImageDataGenerator(rescale=1./255)

train_generator = train_data_generator.flow_from_directory('/content/gdrive/MyDrive/college',
                                                            target_size=(IMG_SIZE, IMG_SIZE),
                                                            batch_size=32,
                                                            class_mode='categorical')

validation_generator = validation_data_generator.flow_from_directory('/content/gdrive/MyDrive/college',
                                                                      target_size=(IMG_SIZE, IMG_SIZE),
                                                                      batch_size=32,
                                                                      class_mode='categorical')

# Define the model architecture
model = Sequential()

base_model = EfficientNetB0(include_top=False, input_shape=(IMG_SIZE, IMG_SIZE, 3))

model.add(base_model)
model.add(GlobalAveragePooling2D())
model.add(Dense(256, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(NUM_CLASSES, activation='softmax'))


# Compile the model
model.compile(optimizer=Adam(lr=0.001), loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
model.fit(train_generator, epochs=1, validation_data=validation_generator)

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.preprocessing import image
import numpy as np

# Set the input image size and number of classes
IMG_SIZE = 224
NUM_CLASSES = 5

# Load the EfficientNet model
#model = tf.keras.models.load_model('efficientnet_model.h5')


model = keras.models.load_model('efficientnet_model.h5')


# Load an image to be classified
img_path = '/content/gdrive/MyDrive/college/test.jpeg'
img = image.load_img(img_path, target_size=(IMG_SIZE, IMG_SIZE))

# Preprocess the image
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)
img_array = tf.keras.applications.efficientnet.preprocess_input(img_array)

# Make predictions
predictions = model.predict(img_array)
class_idx = np.argmax(predictions[0])
if class_idx >= len(class_names):
    class_idx = len(class_names) - 1

class_names = ['No Diabetes Retinopathy', 'Mild', 'Moderate', 'Severe', 'Proliferative Diabetic Retinopathy']
class_name = class_names[class_idx]

print('Predicted class:', class_name)



# Load pre-trained EfficientNetB0 model
model = EfficientNetB0(weights='imagenet')

# Load an image to be classified
img_path = '/content/gdrive/MyDrive/12345/test/No_DR Clahe/Clahe_imgs/processed_fusion_0-1_L.png'
img = image.load_img(img_path, target_size=(224, 224))

# Preprocess the image
x = image.img_to_array(img)
x = np.expand_dims(x, axis=0)
x = preprocess_input(x)

# Make prediction
pred = model.predict(x)

# Print predicted class probabilities
print(pred)

# Get the index of the predicted class
predicted_class_index = np.argmax(pred[0])

# Print predicted class index and label
print("Predicted class index: ", predicted_class_index)
if predicted_class_index == 0:
    print('Class 1')
else:
    print('Class 2')

import torch
from efficientnet_pytorch import EfficientNet

# Define the EfficientNet model
#model = EfficientNet.from_pretrained('efficientnet-b0')
model = tf.keras.models.load_model('efficientnet_model.h5')



save_path = '/path/to/efficientnet_model.h5'
torch.save(model.state_dict(), save_path)

import tensorflow as tf
from tensorflow.keras.applications.efficientnet import EfficientNetB0
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.efficientnet import preprocess_input
import numpy as np

# Load pre-trained EfficientNetB0 model
model = EfficientNetB0(weights='imagenet')

# Load an image to be classified
img_path = '/content/gdrive/MyDrive/college/test.jpeg'
img = image.load_img(img_path, target_size=(224, 224))

# Preprocess the image
x = image.img_to_array(img)
x = np.expand_dims(x, axis=0)
x = preprocess_input(x)

# Make prediction
pred = model.predict(x)

# Print predicted class
if pred[0][0] > pred[0][1]:
    print('Class 1')
else:
    print('Class 2')
pred = model.predict(x)
print(pred)
predicted_class_index = np.argmax(pred)
print(predicted_class_index)

pred = model.predict(x)
print(pred)
predicted_class_index = np.argmax(pred)
print(predicted_class_index)