# -*- coding: utf-8 -*-
"""Fusion & Preprocessing All in 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e2reqBYAbnwvExXKitFWwKSkvbHNgENF
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
from google.colab.patches import cv2_imshow
import tensorflow
import keras
import os
import glob
from skimage import io
import random
import numpy as np
import matplotlib.pyplot as plt
import cv2 as cv2
# %matplotlib inline

import os
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Input folder path that contains the images
input_folder_path = '/content/drive/MyDrive/No_DR4'

# Output folder path to save the fused images
output_folder_path = '/content/drive/MyDrive/Output'

# Common size for all images
width = 224
height = 224

# Get list of all image filenames in the folder
img_fn = [os.path.join(input_folder_path, filename) for filename in os.listdir(input_folder_path) if filename.endswith('.jpg') or filename.endswith('.png')]

# Read in and resize all the images
img_list = []
for fn in img_fn:
    try:
        img = Image.open(fn)
        img = img.resize((width, height))
        img_arr = np.asarray(img)
        img_list.append(img_arr)
    except Exception as e:
        print(f"Error: could not read or resize image {fn}")
        print(e)

# Pairwise merge
mergeMertens = cv2.createMergeMertens()
for i in range(0, len(img_list)-1, 2):
    resFusion = mergeMertens.process([img_list[i], img_list[i+1]])
    # Save the fused image to output folder
    out_fn = f"fusion_{i}-{i+1}.png"
    cv2.imwrite(os.path.join(output_folder_path, out_fn), resFusion*255)
    # Display the fused image
    img = cv2.imread(os.path.join(output_folder_path, out_fn))
    if img is not None:
        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        plt.show()
    else:
        print(f"Error: could not read image {out_fn}")

import os
import cv2
import matplotlib.pyplot as plt

# Folder path that contains the images
folder_path = '/content/drive/MyDrive/Output'

# Common size for all images
width = 224
height = 224

# Path to save the L channel images
save_path = '/content/L_channel_images'

if not os.path.exists(save_path):
    os.makedirs(save_path)

# Read in and resize all the images
img_list = []
for filename in os.listdir(folder_path):
    if filename.endswith(".png"):
        img = cv2.imread(os.path.join(folder_path, filename))
        if img is not None:
            img = cv2.resize(img, (width, height))
            img_list.append(img)

# Pairwise merge
mergeMertens = cv2.createMergeMertens()
for i in range(0, len(img_list)-1, 2):
    resFusion = mergeMertens.process([img_list[i], img_list[i+1]])
    # Save the fused image
    out_fn = os.path.join(save_path, f"fusion_{i}-{i+1}_L.png")
    l_channel = cv2.cvtColor(resFusion, cv2.COLOR_RGB2LAB)[:,:,0]
    cv2.imwrite(out_fn, l_channel)
    # Display the fused image
    plt.imshow(l_channel, cmap='gray')
    plt.show()

import os
import cv2
from google.colab.patches import cv2_imshow

# Folder path that contains the fused images
folder_path = '/content/L_channel_images'

# Output folder path to save the processed images
output_path = '/content/drive/MyDrive/Clahe_imgs'

# Create the output folder if it doesn't exist
if not os.path.exists(output_path):
    os.makedirs(output_path)

# Iterate through the fused images in the input folder
for filename in os.listdir(folder_path):
    if filename.endswith(".png"):
        # Read in the fused image and convert to LAB color space
        bgr = cv2.imread(os.path.join(folder_path, filename))
        lab = cv2.cvtColor(bgr, cv2.COLOR_BGR2LAB)

        # Split the LAB image into its planes
        l, a, b = cv2.split(lab)

        # Apply CLAHE to the L channel
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        l = clahe.apply(l)

        # Merge the LAB planes back into an LAB image
        lab = cv2.merge((l, a, b))

        # Convert the LAB image back to BGR for display
        bgr = cv2.cvtColor(lab, cv2.COLOR_LAB2BGR)


        # Display the L channel of the LAB image
        cv2_imshow(l)
        cv2.waitKey(0)

        # Display the processed image
        cv2_imshow(bgr)
        cv2.waitKey(0)

        # Save the processed image to the output folder
        out_filename = f"processed_{filename}"
        out_path = os.path.join(output_path, out_filename)
        cv2.imwrite(out_path, bgr)

# Close all windows
cv2.destroyAllWindows()

import shutil
shutil.rmtree('/content/L_channel_images', ignore_errors=True)

